// Code generated by {{.Meta.GeneratorName}}. DO NOT EDIT.
// generated_at_utc: {{.Meta.GeneratedAtUTC}}
// version: {{.Meta.GeneratorVersion}}

package {{.Package}}

import (
{{- range .Meta.Imports }}
	{{ . }}
{{- end }}
)

var (
	{{.Meta.LowerTypeName}}FieldNames          = builder.RawFieldNames(&{{.Meta.TypeName}}{}, true)
	{{.Meta.LowerTypeName}}Rows                = strings.Join({{.Meta.LowerTypeName}}FieldNames, ",")
	{{.Meta.LowerTypeName}}RowsExpectAutoSet   = strings.Join(stringx.Remove({{.Meta.LowerTypeName}}FieldNames{{- range .Meta.AutoSetColumns}}, "{{.}}"{{- end}}), ",")

	{{.Meta.TypeName}}Fields = struct {
		{{- range .Meta.Columns }}
		{{.Field}} Field{{ GoTypeToFieldType .GoType }}
		{{- end }}
	}{
		{{- range .Meta.Columns }}
		{{.Field}}: Field{{ GoTypeToFieldType .GoType }}("{{.ColName}}"),
		{{- end }}
	}
)

type (
	{{.Meta.TypeName}}Field interface {
		ColumnName() string
	}
)

type (
	// {{.Meta.LowerTypeName}}Model is an interface to be customized, add more methods here,
	// and implement the added methods in custom model.
	{{.Meta.LowerTypeName}}Model interface {
		// Insert 插入数据并返回 sql.Result (不返回自增主键)
		Insert(ctx context.Context, data *{{.Meta.TypeName}}) (sql.Result, error)
		// InsertReturn 插入数据并返回完整对象 (包含自增主键)
		InsertReturn(ctx context.Context, session sqlx.Session, data *{{.Meta.TypeName}}) (*{{.Meta.TypeName}}, error)
		// UpsertReturn 仅更新非零值字段。如果字段值为 0 或空字符串，则忽略更新。
		UpsertReturn(ctx context.Context, session sqlx.Session, data *{{.Meta.TypeName}}) (*{{.Meta.TypeName}}, error)
		// UpsertAll 更新所有字段，包括 0 值 and 空字符串。主键/唯一索引冲突时触发更新。
		UpsertAll(ctx context.Context, session sqlx.Session, data *{{.Meta.TypeName}}) (*{{.Meta.TypeName}}, error)
		// BatchInsertReturn 批量插入数据并返回所有对象
		BatchInsertReturn(ctx context.Context, session sqlx.Session, dataList []*{{.Meta.TypeName}}) ([]*{{.Meta.TypeName}}, error)
		// FindOne 根据主键查询单条数据
		FindOne(ctx context.Context{{range .Meta.PKParams}}, {{.Name}} {{.GoType}}{{end}}) (*{{.Meta.TypeName}}, error)
		// FindByIndex 自动构建 WHERE 条件（非零字段），并仅返回索引覆盖的列
		FindByIndex(ctx context.Context, req *{{.Meta.TypeName}}Index) ([]*{{.Meta.TypeName}}Index, error)
		// Update 根据主键更新数据 (全量覆盖)
		Update(ctx context.Context, data *{{.Meta.TypeName}}) error
		// Delete 根据主键删除数据
		Delete(ctx context.Context{{range .Meta.PKParams}}, {{.Name}} {{.GoType}}{{end}}) error
		// SelectBuilder 链式查询构造器
		SelectBuilder(ctx context.Context, fields ...{{.Meta.TypeName}}Field) *{{.Meta.TypeName}}Selector
	}

	default{{.Meta.TypeName}}Model struct {
		conn  sqlx.SqlConn
		table string
	}

	// {{.Meta.TypeName}} represents a row in table "{{.Meta.Schema}}"."{{.Meta.Table}}".
	{{.Meta.TypeName}} struct {
	{{- range .Meta.Columns }}
		{{.Field}} {{.GoType}} `db:"{{.ColName}}"`{{if .Comment}} // {{.Comment}}{{end}}
	{{- end }}
	}

	// {{.Meta.TypeName}}Index 仅包含表中所有出现在索引中的列，用于覆盖索引查询优化
	{{.Meta.TypeName}}Index struct {
	{{- range .Meta.IndexedColumns }}
		{{.Field}} {{.GoType}} `db:"{{.ColName}}"`{{if .Comment}} // {{.Comment}}{{end}}
	{{- end }}
	}

	// {{.Meta.TypeName}}Selector 是 {{.Meta.TypeName}} 的链式查询构造器
	{{.Meta.TypeName}}Selector struct {
		ctx     context.Context
		model   *default{{.Meta.TypeName}}Model
		builder squirrel.SelectBuilder
		err     error
	}
)

func new{{.Meta.TypeName}}Model(conn sqlx.SqlConn) *default{{.Meta.TypeName}}Model {
	return &default{{.Meta.TypeName}}Model{
		conn:  conn,
		table: "\"{{.Meta.Schema}}\".\"{{.Meta.Table}}\"",
	}
}

func (m *default{{.Meta.TypeName}}Model) Delete(ctx context.Context{{range .Meta.PKParams}}, {{.Name}} {{.GoType}}{{end}}) error {
	query := fmt.Sprintf("delete from %s where {{range $i, $pk := .Meta.PKColumns}}{{if $i}} and {{end}}{{$pk}} = ${{Add $i 1}}{{end}}", m.table)
	_, err := m.conn.ExecCtx(ctx, query{{- range .Meta.PKParams}}, {{.Name}}{{- end}})
	return err
}

func (m *default{{.Meta.TypeName}}Model) FindOne(ctx context.Context{{range .Meta.PKParams}}, {{.Name}} {{.GoType}}{{end}}) (*{{.Meta.TypeName}}, error) {
	query := fmt.Sprintf("select %s from %s where {{range $i, $pk := .Meta.PKColumns}}{{if $i}} and {{end}}{{$pk}} = ${{Add $i 1}}{{end}} limit 1", {{.Meta.LowerTypeName}}Rows, m.table)
	var resp {{.Meta.TypeName}}
	err := m.conn.QueryRowCtx(ctx, &resp, query{{- range .Meta.PKParams}}, {{.Name}}{{- end}})
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

// FindByIndex 自动构建 WHERE 条件（非零字段），并仅返回索引覆盖的列
func (m *default{{.Meta.TypeName}}Model) FindByIndex(ctx context.Context, req *{{.Meta.TypeName}}Index) ([]*{{.Meta.TypeName}}Index, error) {
	builder := m.selectBuilder()
	{{- range .Meta.IndexedColumns }}
	{{- if or (eq .GoType "int") (eq .GoType "int64") (eq .GoType "int32") (eq .GoType "uint64") (eq .GoType "uint32") (eq .GoType "float64") (eq .GoType "float32")}}
	if req.{{.Field}} != 0 {
		builder = builder.Where(squirrel.Eq{"{{.ColName}}": req.{{.Field}}})
	}
	{{- else if eq .GoType "string" }}
	if req.{{.Field}} != "" {
		builder = builder.Where(squirrel.Eq{"{{.ColName}}": req.{{.Field}}})
	}
	{{- else if eq .GoType "decimal.Decimal" }}
	if !req.{{.Field}}.IsZero() {
		builder = builder.Where(squirrel.Eq{"{{.ColName}}": req.{{.Field}}})
	}
	{{- end }}
	{{- end }}

	// Select only indexed columns to enable Covering Index (if query matches index)
	builder = builder.Columns({{range $i, $c := .Meta.IndexedColumns}}{{if $i}}, {{end}}"{{$c.ColName}}"{{end}})

	query, values, err := builder.ToSql()
	if err != nil {
		return nil, err
	}
	
	var resp []*{{.Meta.TypeName}}Index
	err = m.conn.QueryRowsCtx(ctx, &resp, query, values...)
	return resp, err
}

func (m *default{{.Meta.TypeName}}Model) Insert(ctx context.Context, data *{{.Meta.TypeName}}) (sql.Result, error) {
	builder := m.insertBuilder().Columns({{.Meta.LowerTypeName}}RowsExpectAutoSet).Values({{range $i, $c := .Meta.InsertColumns}}{{if $i}}, {{end}}data.{{$c.Field}}{{end}})
	querySql, values, err := builder.ToSql()
	if err != nil {
		return nil, err
	}
	return m.conn.ExecCtx(ctx, querySql, values...)
}

func (m *default{{.Meta.TypeName}}Model) BatchInsertReturn(ctx context.Context, session sqlx.Session, dataList []*{{.Meta.TypeName}}) ([]*{{.Meta.TypeName}}, error) {
	builder := m.insertBuilder().Columns({{.Meta.LowerTypeName}}RowsExpectAutoSet)
	for _, data := range dataList {
		builder = builder.Values({{range $i, $c := .Meta.InsertColumns}}{{if $i}}, {{end}}data.{{$c.Field}}{{end}})
	}
	return m.insertListWithReturn(ctx, session, builder)
}

func (m *default{{.Meta.TypeName}}Model) InsertReturn(ctx context.Context, session sqlx.Session, data *{{.Meta.TypeName}}) (*{{.Meta.TypeName}}, error) {
	builder := m.insertBuilder().Columns({{.Meta.LowerTypeName}}RowsExpectAutoSet).Values({{range $i, $c := .Meta.InsertColumns}}{{if $i}}, {{end}}data.{{$c.Field}}{{end}})
	return m.insertWithReturn(ctx, session, builder)
}

func (m *default{{.Meta.TypeName}}Model) UpsertReturn(ctx context.Context, session sqlx.Session, data *{{.Meta.TypeName}}) (*{{.Meta.TypeName}}, error) {
	builder := m.insertBuilder().Columns({{.Meta.LowerTypeName}}RowsExpectAutoSet).Values({{range $i, $c := .Meta.InsertColumns}}{{if $i}}, {{end}}data.{{$c.Field}}{{end}})
	var updateStr string
	{{- range $i, $c := .Meta.UpdateColumns}}
	{{- if $i}}
	updateStr += ", "
	{{- end}}
	{{- if eq .GoType "string"}}
	updateStr += fmt.Sprintf("{{.ColName}} = CASE WHEN EXCLUDED.{{.ColName}} = '' THEN %s.{{.ColName}} ELSE EXCLUDED.{{.ColName}} END", m.table)
	{{- else if or (eq .GoType "int") (eq .GoType "int64") (eq .GoType "int32") (eq .GoType "uint64") (eq .GoType "uint32") (eq .GoType "float64") (eq .GoType "float32")}}
	updateStr += fmt.Sprintf("{{.ColName}} = CASE WHEN EXCLUDED.{{.ColName}} = 0 THEN %s.{{.ColName}} ELSE EXCLUDED.{{.ColName}} END", m.table)
	{{- else if eq .GoType "time.Time"}}
	updateStr += fmt.Sprintf("{{.ColName}} = CASE WHEN EXCLUDED.{{.ColName}} = '0001-01-01 00:00:00Z' THEN %s.{{.ColName}} ELSE EXCLUDED.{{.ColName}} END", m.table)
	{{- else if eq .GoType "[]byte"}}
	updateStr += fmt.Sprintf("{{.ColName}} = CASE WHEN EXCLUDED.{{.ColName}} = '' THEN %s.{{.ColName}} ELSE EXCLUDED.{{.ColName}} END", m.table)
	{{- else if or (eq .GoType "pq.StringArray") (eq .GoType "pq.Int64Array") (eq .GoType "pq.Float64Array") (eq .GoType "pq.BoolArray")}}
	updateStr += fmt.Sprintf("{{.ColName}} = CASE WHEN cardinality(EXCLUDED.{{.ColName}}) = 0 THEN %s.{{.ColName}} ELSE EXCLUDED.{{.ColName}} END", m.table)
	{{- else}}
	updateStr += "{{.ColName}} = EXCLUDED.{{.ColName}}"
	{{- end}}
	{{- end}}
	suffix := fmt.Sprintf("ON CONFLICT ({{range $i, $pk := .Meta.PKColumns}}{{if $i}}, {{end}}{{$pk}}{{end}}) DO UPDATE SET %s", updateStr)
	return m.insertWithReturn(ctx, session, builder.Suffix(suffix))
}

func (m *default{{.Meta.TypeName}}Model) UpsertAll(ctx context.Context, session sqlx.Session, data *{{.Meta.TypeName}}) (*{{.Meta.TypeName}}, error) {
	builder := m.insertBuilder().Columns({{.Meta.LowerTypeName}}RowsExpectAutoSet).Values({{range $i, $c := .Meta.InsertColumns}}{{if $i}}, {{end}}data.{{$c.Field}}{{end}})
	var updateStr string
	{{- range $i, $c := .Meta.UpdateColumns}}
	{{- if $i}}
	updateStr += ", "
	{{- end}}
	updateStr += "{{.ColName}} = EXCLUDED.{{.ColName}}"
	{{- end}}
	suffix := fmt.Sprintf("ON CONFLICT ({{range $i, $pk := .Meta.PKColumns}}{{if $i}}, {{end}}{{$pk}}{{end}}) DO UPDATE SET %s", updateStr)
	return m.insertWithReturn(ctx, session, builder.Suffix(suffix))
}

func (m *default{{.Meta.TypeName}}Model) Update(ctx context.Context, newData *{{.Meta.TypeName}}) error {
	builder := m.updateBuilder()
	{{- range .Meta.UpdateColumns}}
	builder = builder.Set("{{.ColName}}", newData.{{.Field}})
	{{- end }}
	builder = builder.Where(squirrel.Eq{
	{{- range .Meta.PKParams}}
		"{{.Column}}": newData.{{.Field}},
	{{- end }}
	})
	return m.execCtxWithSession(ctx, nil, builder)
}

func (m *default{{.Meta.TypeName}}Model) tableName() string {
	return m.table
}

func (m *default{{.Meta.TypeName}}Model) selectBuilder() squirrel.SelectBuilder {
	return squirrel.Select().PlaceholderFormat(squirrel.Dollar).From(m.table)
}

func (m *default{{.Meta.TypeName}}Model) insertBuilder() squirrel.InsertBuilder {
	return squirrel.Insert(m.table).PlaceholderFormat(squirrel.Dollar)
}

func (m *default{{.Meta.TypeName}}Model) replaceBuilder() squirrel.InsertBuilder {
	return squirrel.Replace(m.table).PlaceholderFormat(squirrel.Dollar)
}

func (m *default{{.Meta.TypeName}}Model) updateBuilder() squirrel.UpdateBuilder {
	return squirrel.Update(m.table).PlaceholderFormat(squirrel.Dollar)
}

func (m *default{{.Meta.TypeName}}Model) deleteBuilder() squirrel.DeleteBuilder {
	return squirrel.Delete(m.table).PlaceholderFormat(squirrel.Dollar)
}

func (m *default{{.Meta.TypeName}}Model) execCtxWithSession(ctx context.Context, session sqlx.Session, sqlizer squirrel.Sqlizer) error {
	sqlStr, args, err := sqlizer.ToSql()
	if err != nil {
		return err
	}
	if session != nil {
		_, err = session.Exec(sqlStr, args...)
	} else {
		_, err = m.conn.ExecCtx(ctx, sqlStr, args...)
	}
	return err
}

func (m *default{{.Meta.TypeName}}Model) insertListWithReturn(ctx context.Context, session sqlx.Session, sqlizer squirrel.InsertBuilder) ([]*{{.Meta.TypeName}}, error) {
	querySql, values, err := sqlizer.Suffix("RETURNING " + {{.Meta.LowerTypeName}}Rows).ToSql()
	if err != nil {
		return nil, err
	}
	var resp []*{{.Meta.TypeName}}
	if session != nil {
		err = session.QueryRowsCtx(ctx, &resp, querySql, values...)
	} else {
		err = m.conn.QueryRowsCtx(ctx, &resp, querySql, values...)
	}
	return resp, err
}

func (m *default{{.Meta.TypeName}}Model) insertWithReturn(ctx context.Context, session sqlx.Session, sqlizer squirrel.InsertBuilder) (*{{.Meta.TypeName}}, error) {
	querySql, values, err := sqlizer.Suffix("RETURNING " + {{.Meta.LowerTypeName}}Rows).ToSql()
	if err != nil {
		return nil, err
	}
	var resp {{.Meta.TypeName}}
	if session != nil {
		err = session.QueryRowCtx(ctx, &resp, querySql, values...)
	} else {
		err = m.conn.QueryRowCtx(ctx, &resp, querySql, values...)
	}
	return &resp, err
}

// findCount 根据squirrel.SelectBuilder生成的sql查询当前表条数
func (m *default{{.Meta.TypeName}}Model) findCount(ctx context.Context, builder squirrel.SelectBuilder) (int64, error) {
	builder = builder.Columns("COUNT(" + m.tableName() + ".{{index .Meta.PKColumns 0}})")
	query, values, err := builder.ToSql()
	if err != nil {
		return 0, err
	}
	var resp int64
	err = m.conn.QueryRowCtx(ctx, &resp, query, values...)
	if err != nil {
		return 0, err
	}
	return resp, nil
}

// findList 根据squirrel.SelectBuilder生成的sql查询当前表所有字段返回对象
func (m *default{{.Meta.TypeName}}Model) findList(ctx context.Context, builder squirrel.SelectBuilder) ([]*{{.Meta.TypeName}}, error) {
	builder = builder.Columns({{.Meta.LowerTypeName}}Rows)
	querySql, values, err := builder.ToSql()
	if err != nil {
		return nil, err
	}
	var resp []*{{.Meta.TypeName}}
	err = m.conn.QueryRowsCtx(ctx, &resp, querySql, values...)
	return resp, err
}

// execResultCtxWithSession 根据sqlizer生产sql执行并返回结果
func (m *default{{.Meta.TypeName}}Model) execResultCtxWithSession(ctx context.Context, session sqlx.Session, sqlizer squirrel.Sqlizer) (sql.Result, error) {
	sqlStr, args, err := sqlizer.ToSql()
	if err != nil {
		return nil, err
	}
	if session != nil {
		return session.Exec(sqlStr, args...)
	}
	return m.conn.ExecCtx(ctx, sqlStr, args...)
}

// updateWithReturn 根据squirrel.UpdateBuilder条件构建更新语句并返回更新后的对象
func (m *default{{.Meta.TypeName}}Model) updateWithReturn(ctx context.Context, session sqlx.Session, sqlizer squirrel.UpdateBuilder) ([]*{{.Meta.TypeName}}, error) {
	querySql, values, err := sqlizer.Suffix("RETURNING " + {{.Meta.LowerTypeName}}Rows).ToSql()
	if err != nil {
		return nil, err
	}
	var resp []*{{.Meta.TypeName}}
	if session != nil {
		err = session.QueryRowsCtx(ctx, &resp, querySql, values...)
	} else {
		err = m.conn.QueryRowsCtx(ctx, &resp, querySql, values...)
	}
	return resp, err
}

// deleteWithReturn 根据squirrel.DeleteBuilder条件构建删除语句并返回被删除的对象
func (m *default{{.Meta.TypeName}}Model) deleteWithReturn(ctx context.Context, session sqlx.Session, sqlizer squirrel.DeleteBuilder) ([]*{{.Meta.TypeName}}, error) {
	querySql, values, err := sqlizer.Suffix("RETURNING " + {{.Meta.LowerTypeName}}Rows).ToSql()
	if err != nil {
		return nil, err
	}
	var resp []*{{.Meta.TypeName}}
	if session != nil {
		err = session.QueryRowsCtx(ctx, &resp, querySql, values...)
	} else {
		err = m.conn.QueryRowsCtx(ctx, &resp, querySql, values...)
	}
	return resp, err
}

// SelectBuilder returns a query builder with selected columns.
// If no columns are provided, all columns are selected.
func (m *default{{.Meta.TypeName}}Model) SelectBuilder(ctx context.Context, fields ...{{.Meta.TypeName}}Field) *{{.Meta.TypeName}}Selector {
	b := m.selectBuilder()
	if len(fields) > 0 {
		cols := make([]string, len(fields))
		for i, f := range fields {
			cols[i] = f.ColumnName()
		}
		b = b.Columns(cols...)
	} else {
		b = b.Columns({{.Meta.LowerTypeName}}Rows)
	}
	return &{{.Meta.TypeName}}Selector{
		ctx:     ctx,
		model:   m,
		builder: b,
	}
}

func (s *{{.Meta.TypeName}}Selector) Where(pred interface{}, args ...interface{}) *{{.Meta.TypeName}}Selector {
	if s.err != nil {
		return s
	}
	s.builder = s.builder.Where(pred, args...)
	return s
}

func (s *{{.Meta.TypeName}}Selector) OrderBy(orderBys ...string) *{{.Meta.TypeName}}Selector {
	if s.err != nil {
		return s
	}
	s.builder = s.builder.OrderBy(orderBys...)
	return s
}

func (s *{{.Meta.TypeName}}Selector) Order(orderBys ...string) *{{.Meta.TypeName}}Selector {
	return s.OrderBy(orderBys...)
}

func (s *{{.Meta.TypeName}}Selector) Limit(limit uint64) *{{.Meta.TypeName}}Selector {
	if s.err != nil {
		return s
	}
	s.builder = s.builder.Limit(limit)
	return s
}

func (s *{{.Meta.TypeName}}Selector) Offset(offset uint64) *{{.Meta.TypeName}}Selector {
	if s.err != nil {
		return s
	}
	s.builder = s.builder.Offset(offset)
	return s
}

func (s *{{.Meta.TypeName}}Selector) FindAll() ([]*{{.Meta.TypeName}}, error) {
	if s.err != nil {
		return nil, s.err
	}
	query, values, err := s.builder.ToSql()
	if err != nil {
		return nil, err
	}
	var resp []*{{.Meta.TypeName}}
	err = s.model.conn.QueryRowsCtx(s.ctx, &resp, query, values...)
	return resp, err
}

func (s *{{.Meta.TypeName}}Selector) FindOne() (*{{.Meta.TypeName}}, error) {
	if s.err != nil {
		return nil, s.err
	}
	s.builder = s.builder.Limit(1)
	
	query, values, err := s.builder.ToSql()
	if err != nil {
		return nil, err
	}
	
	var resp {{.Meta.TypeName}}
	err = s.model.conn.QueryRowCtx(s.ctx, &resp, query, values...)
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (s *{{.Meta.TypeName}}Selector) Count() (int64, error) {
	if s.err != nil {
		return 0, s.err
	}
	// Use a clean builder for count, preserving where clauses but replacing columns
	// Note: squirrel doesn't easily support replacing columns on an existing builder without internal knowledge
	// So we might need to rely on how the builder was constructed. 
	// A safer way for count is to rely on m.findCount but we need the builder.
	// But `m.findCount` modifies the passed builder to set columns to COUNT(*). 
	// Since `squirrel` returns a new builder on modification, we can pass `s.builder`.
	
	return s.model.findCount(s.ctx, s.builder)
}
